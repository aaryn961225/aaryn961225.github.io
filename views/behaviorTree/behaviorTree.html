<!DOCTYPE html>
<html lang="zh-TW">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NPCè¡Œç‚ºæ¨¹æ¨¡æ“¬å™¨ (å®Œæ•´å¿ƒç†å­¸ç‰ˆ)</title>
  <style>
    /* ====== åŸºç¤æ¨£å¼ ====== */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      min-height: 100vh;
      padding: 20px;
      color: #2d3748;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: #fff;
      border-radius: 20px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, .1);
      display: flex;
      flex-direction: column;
      /* é—œéµä¿®æ­£ï¼šç§»é™¤ overflow: hidden é¿å…å…§å®¹è¢«å¡æ‰ */
    }

    .header {
      background: #2d3748;
      color: #fff;
      padding: 24px;
      text-align: center;
      border-radius: 20px 20px 0 0;
    }

    .header h1 {
      font-size: 24px;
      margin-bottom: 8px;
    }

    .header p {
      opacity: 0.8;
      font-size: 14px;
    }

    .main-content {
      display: grid;
      grid-template-columns: 300px 1fr 300px;
      gap: 24px;
      padding: 24px;
      background: #f8fafc;
    }

    /* é¢æ¿å…±åŒæ¨£å¼ */
    .personality-panel,
    .commands-panel {
      background: #fff;
      border-radius: 12px;
      padding: 20px;
      border: 1px solid #e2e8f0;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
      height: fit-content;
    }

    .panel-title {
      font-size: 16px;
      font-weight: 700;
      margin-bottom: 16px;
      color: #1a202c;
      padding-bottom: 10px;
      border-bottom: 2px solid #edf2f7;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    /* ====== ä¸­é–“è§’è‰²å€ ====== */
    .character-area {
      background: linear-gradient(180deg, #2d3748 0%, #1a202c 100%);
      border-radius: 16px;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 30px;
      color: #fff;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
      /* min-height: 500px; */
      height: 69vh;
    }

    .character {
      width: 140px;
      height: 140px;
      background: linear-gradient(135deg, #63b3ed, #4299e1);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 64px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, .4);
      transition: all .3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      margin-bottom: 24px;
      border: 4px solid rgba(255, 255, 255, 0.2);
    }

    /* æƒ…ç·’å‹•ç•«ç‹€æ…‹ */
    .character.happy {
      background: linear-gradient(135deg, #68d391, #48bb78);
      transform: scale(1.1) rotate(5deg);
    }

    .character.angry {
      background: linear-gradient(135deg, #fc8181, #f56565);
      transform: scale(1.1) rotate(-5deg);
      animation: shake .5s ease-in-out;
    }

    .character.sad {
      background: linear-gradient(135deg, #90cdf4, #63b3ed);
      transform: scale(.95);
      filter: grayscale(0.5);
    }

    .character.fearful {
      background: linear-gradient(135deg, #b794f4, #9f7aea);
      transform: scale(.9) translateY(10px);
      animation: tremble .2s infinite;
    }

    @keyframes shake {

      0%,
      100% {
        transform: scale(1.1) rotate(-5deg);
      }

      50% {
        transform: scale(1.1) rotate(5deg);
      }
    }

    @keyframes tremble {

      0%,
      100% {
        transform: scale(.9) translateY(10px) translateX(-1px);
      }

      50% {
        transform: scale(.9) translateY(10px) translateX(1px);
      }
    }

    .status-display {
      text-align: center;
      padding: 15px;
      background: rgba(255, 255, 255, .1);
      backdrop-filter: blur(5px);
      border-radius: 12px;
      width: 100%;
      margin-bottom: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* ====== Log å€åŸŸ ====== */
    .log-area {
      background: rgba(0, 0, 0, 0.3);
      color: #a0aec0;
      border-radius: 8px;
      padding: 12px;
      width: 100%;
      flex: 1;
      overflow-y: auto;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 13px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .log-entry {
      margin-bottom: 6px;
      padding: 4px 8px;
      border-radius: 4px;
      animation: slideIn 0.3s ease;
      line-height: 1.4;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-10px);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .log-entry.action {
      color: #68d391;
      border-left: 2px solid #68d391;
      background: rgba(104, 211, 145, 0.1);
    }

    .log-entry.emotion {
      color: #d6bcfa;
      border-left: 2px solid #d6bcfa;
      background: rgba(183, 148, 244, 0.1);
    }

    .log-entry.decision {
      color: #63b3ed;
      border-left: 2px solid #63b3ed;
      background: rgba(99, 179, 237, 0.1);
    }

    /* ====== æ»‘æ¡¿èˆ‡æŒ‰éˆ• ====== */
    .trait-slider {
      margin-bottom: 15px;
    }

    .trait-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 6px;
      font-size: 13px;
      font-weight: 600;
      color: #718096;
    }

    .slider {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: #edf2f7;
      outline: none;
      -webkit-appearance: none;
      cursor: pointer;
    }

    .slider::-webkit-slider-thumb {
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #4299e1;
      transition: transform .2s;
      border: 2px solid #fff;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .slider::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }

    .command-btn {
      width: 100%;
      padding: 12px;
      margin-bottom: 8px;
      border: none;
      border-radius: 8px;
      background: #fff;
      color: #4a5568;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all .2s;
      border: 1px solid #e2e8f0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .command-btn:hover {
      background: #ebf8ff;
      border-color: #bee3f8;
      color: #2b6cb0;
      transform: translateX(2px);
    }

    .command-btn:active {
      transform: scale(0.98);
    }

    /* ====== è¡Œç‚ºæ¨¹é¢æ¿ (é‡é»å„ªåŒ–) ====== */
    .bt-panel {
      padding: 0 24px 24px 24px;
      background: #f8fafc;
      border-radius: 0 0 20px 20px;
    }

    .bt-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .bt-toolbar {
      display: flex;
      gap: 10px;
    }

    .bt-btn {
      padding: 6px 12px;
      border-radius: 6px;
      border: 1px solid #cbd5e0;
      background: #fff;
      color: #4a5568;
      cursor: pointer;
      font-size: 13px;
    }

    .bt-btn:hover {
      background: #edf2f7;
    }

    /* é—œéµä¿®æ­£ï¼šå…è¨±æ²å‹•ï¼Œé¿å…å¡æ‰ */
    .bt-wrap {
      background-color: #1a202c;
      background-image: linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
      background-size: 20px 20px;
      border: 1px solid #2d3748;
      border-radius: 12px;
      width: 100%;
      height: 500px;
      overflow: auto;
      /* é¡¯ç¤ºæ²è»¸ */
      position: relative;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
    }

    svg.bt {
      display: block;
      min-width: 100%;
      min-height: 100%;
    }

    .node rect {
      rx: 6;
      ry: 6;
      stroke: #4a5568;
      stroke-width: 1.5;
      fill: #2d3748;
      filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 0.3));
    }

    .node text {
      font-size: 12px;
      fill: #cbd5e0;
      font-weight: 500;
      pointer-events: none;
    }

    /* ç¯€é»é¡è‰² */
    .node.selector rect {
      stroke: #d69e2e;
      fill: #2d3748;
    }

    .node.sequence rect {
      stroke: #38a169;
      fill: #2d3748;
    }

    .node.condition rect {
      stroke: #3182ce;
      fill: #232d3f;
      stroke-dasharray: 4;
    }

    .node.action rect {
      stroke: #805ad5;
      fill: #2d3748;
    }

    /* ç‹€æ…‹ */
    .node.success rect {
      stroke: #48bb78;
      stroke-width: 3;
      fill: rgba(72, 187, 120, 0.2);
    }

    .node.failure rect {
      stroke: #f56565;
      stroke-width: 3;
      fill: rgba(245, 101, 101, 0.2);
    }

    .link {
      stroke: #718096;
      stroke-width: 1.5;
      fill: none;
      transition: all 0.3s;
    }

    .link.active {
      stroke: #48bb78;
      stroke-width: 2.5;
      filter: drop-shadow(0 0 3px #48bb78);
    }

    .legend {
      position: sticky;
      bottom: 12px;
      right: 12px;
      float: right;
      background: rgba(26, 32, 44, 0.9);
      border: 1px solid #4a5568;
      border-radius: 6px;
      padding: 6px 12px;
      font-size: 11px;
      color: #a0aec0;
      z-index: 10;
      margin-top: -40px;
      margin-right: 12px;
    }

    /* ====== è¨˜æ†¶æ¨™ç±¤æ¨£å¼ ====== */
    .memory-item {
      padding: 4px 8px;
      margin-bottom: 4px;
      border-radius: 4px;
      background: #edf2f7;
      border-left: 3px solid #cbd5e0;
      animation: slideIn 0.3s ease;
    }

    .memory-item.negative {
      background: #fff5f5;
      border-left-color: #f56565;
      /* ç´…è‰²ï¼šè² é¢è¨˜æ†¶ */
      color: #c53030;
    }

    .memory-item.positive {
      background: #f0fff4;
      border-left-color: #48bb78;
      /* ç¶ è‰²ï¼šæ­£é¢è¨˜æ†¶ */
      color: #2f855a;
    }

    /* RWD */
    @media (max-width: 1024px) {
      .main-content {
        grid-template-columns: 1fr;
      }

      .character-area {
        order: -1;
        min-height: 400px;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>ğŸ¤– NPC è¡Œç‚ºæ¨¹æ¨¡æ“¬å™¨</h1>
      <p>åŸºæ–¼äº”å¤§æ€§æ ¼ç‰¹è³ª (Big Five) èˆ‡è¡Œç‚ºæ¨¹ (Behavior Tree) çš„å‹•æ…‹æ±ºç­–ç³»çµ±</p>
    </div>

    <div class="main-content">
      <div class="personality-panel">
        <div class="panel-title">ğŸ§  äººæ ¼ç‰¹è³ª (Big Five)</div>
        <div class="trait-slider">
          <div class="trait-label"><span>é–‹æ”¾æ€§ (Openness)</span><span id="openness-value">0.5</span></div>
          <input type="range" min="0" max="1" step="0.1" value="0.5" class="slider" id="openness">
        </div>
        <div class="trait-slider">
          <div class="trait-label"><span>ç›¡è²¬æ€§ (Conscientiousness)</span><span id="conscientiousness-value">0.5</span>
          </div>
          <input type="range" min="0" max="1" step="0.1" value="0.5" class="slider" id="conscientiousness">
        </div>
        <div class="trait-slider">
          <div class="trait-label"><span>å¤–å‘æ€§ (Extraversion)</span><span id="extraversion-value">0.5</span></div>
          <input type="range" min="0" max="1" step="0.1" value="0.5" class="slider" id="extraversion">
        </div>
        <div class="trait-slider">
          <div class="trait-label"><span>å®œäººæ€§ (Agreeableness)</span><span id="agreeableness-value">0.5</span></div>
          <input type="range" min="0" max="1" step="0.1" value="0.5" class="slider" id="agreeableness">
        </div>
        <div class="trait-slider">
          <div class="trait-label"><span>ç¥ç¶“è³ª (Neuroticism)</span><span id="neuroticism-value">0.5</span></div>
          <input type="range" min="0" max="1" step="0.1" value="0.5" class="slider" id="neuroticism">
        </div>

        <div style="margin-top: 20px; padding-top:15px; border-top: 1px dashed #e2e8f0;">
          <div class="trait-label"><span>ğŸ¤ å°ç©å®¶ä¿¡ä»»åº¦</span><span id="trust-value">0.50</span></div>
          <div style="height: 8px; background: #edf2f7; border-radius: 4px; overflow: hidden;">
            <div id="trust-bar" style="width: 50%; height: 100%; background: #48bb78; transition: width 0.3s;"></div>
          </div>
        </div>

        <div style="margin-top: 20px; padding-top:15px; border-top: 1px dashed #e2e8f0;">
          <div class="panel-title" style="font-size:14px; border:none; margin-bottom:8px;">ğŸ“‚ çŸ­æœŸè¨˜æ†¶ (Short-term Memory)
          </div>
          <div id="memory-list" style="font-size: 12px; color: #718096; min-height: 60px;">
            <div style="font-style: italic; opacity: 0.6;">(å°šç„¡é—œéµè¨˜æ†¶)</div>
          </div>
        </div>
      </div>

      <div class="character-area">
        <div class="character" id="character">ğŸ¤–</div>
        <div class="status-display">
          <h3 id="character-name" style="margin-bottom:5px;">æ™ºèƒ½ NPC</h3>
          <p id="character-status" style="font-size:18px; font-weight:bold; color:#fff;">ç­‰å¾…æŒ‡ä»¤ä¸­...</p>
          <p id="current-emotion" style="margin-top:5px; opacity:0.8;">æƒ…ç·’: å¹³éœ</p>
        </div>

        <div class="log-area" id="log-area">
          <div class="log-entry action">ç³»çµ±å•Ÿå‹• - NPCåˆå§‹åŒ–å®Œæˆ</div>
          <div class="log-entry emotion">æƒ…ç·’ç‹€æ…‹: å¹³éœ (å¼·åº¦: 0.00)</div>
          <div class="log-entry decision">ç­‰å¾…ç©å®¶æŒ‡ä»¤...</div>
        </div>
      </div>

      <div class="commands-panel">
        <div class="panel-title">ğŸ® ç©å®¶æŒ‡ä»¤</div>
        <button class="command-btn" onclick="executeCommand('greet')">ğŸ‘‹ æ‰“æ‹›å‘¼ (Greet)</button>
        <button class="command-btn" onclick="executeCommand('help')">ğŸ¤ è«‹æ±‚å¹«åŠ© (Help)</button>
        <button class="command-btn" onclick="executeCommand('attack')">âš”ï¸ ç™¼èµ·æ”»æ“Š (Attack)</button>
        <button class="command-btn" onclick="executeCommand('gift')">ğŸ è´ˆé€ç¦®ç‰© (Gift)</button>
        <button class="command-btn" onclick="executeCommand('threaten')">ğŸ˜  å¨è„…æåš‡ (Threaten)</button>
        <button class="command-btn" onclick="executeCommand('explore')">ğŸ—ºï¸ é‚€è«‹æ¢ç´¢ (Explore)</button>
        <button class="command-btn" onclick="executeCommand('trade')">ğŸ’° å•†æ¥­äº¤æ˜“ (Trade)</button>
        <button class="command-btn" onclick="executeCommand('joke')">ğŸ˜„ èªªç¬‘è©± (Joke)</button>
        <button class="command-btn" onclick="executeCommand('sad_news')">ğŸ˜¢ å‘ŠçŸ¥å£æ¶ˆæ¯ (Bad News)</button>
        <div style="margin-top: 15px; border-top: 1px dashed #e2e8f0; padding-top: 10px;">
          <button class="command-btn" style="background:#fff5f5; color:#c53030; border-color:#feb2b2;"
            onclick="executeCommand('reset')">ğŸ”„ é‡ç½®ç‹€æ…‹</button>
        </div>
      </div>
    </div>

    <div class="bt-panel">
      <div class="bt-header">
        <div class="panel-title" style="border:none; margin:0;">ğŸ§­ è¡Œç‚ºæ¨¹æ±ºç­–å¯è¦–åŒ– (Behavior Tree)</div>
        <div class="bt-toolbar">
          <button class="bt-btn" id="btn-relayout">é‡æ’ç‰ˆé¢</button>
          <button class="bt-btn" id="btn-toggle-label" style="min-width: 130px">é¡¯ç¤ºï¼šä¸­æ–‡æè¿°</button>
        </div>
      </div>
      <div class="bt-wrap">
        <svg class="bt" id="bt-svg">
          <defs>
            <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="6" markerHeight="6"
              orient="auto-start-reverse">
              <path d="M 0 0 L 10 5 L 0 10 z" fill="#718096"></path>
            </marker>
            <marker id="arrow-active" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="6" markerHeight="6"
              orient="auto-start-reverse">
              <path d="M 0 0 L 10 5 L 0 10 z" fill="#48bb78"></path>
            </marker>
          </defs>
        </svg>
        <div class="legend">ğŸŸ¢ åŸ·è¡ŒæˆåŠŸ &nbsp;|&nbsp; ğŸ”´ åŸ·è¡Œå¤±æ•— &nbsp;|&nbsp; âœ¨ é«˜äº®=æ±ºç­–è·¯å¾‘</div>
      </div>
    </div>
  </div>

  <script>
    /* ================== NPC æ•¸æ“šèˆ‡è¨­å®š ================== */
    let npc = {
      personality: { openness: .5, conscientiousness: .5, extraversion: .5, agreeableness: .5, neuroticism: .5 },
      emotions: { joy: 0.0, anger: 0.0, fear: 0.0, sadness: 0.0 },
      currentEmotion: 'neutral',
      trust: .5,
      memories: [] // æ–°å¢ï¼šè¨˜æ†¶å„²å­˜é™£åˆ—
    };
    const MAX_LOG = 50;

    const behaviorDatabase = {
      greet: { baseResponse: "ä½ å¥½ï¼", personalityEffects: { extraversion: { positive: "ç†±æƒ…åœ°æ‰“æ‹›å‘¼ï¼å˜¿ï¼", negative: "é»é ­ç¤ºæ„ã€‚" }, agreeableness: { positive: "å¾®ç¬‘è‘—å›æ‡‰ä½ ã€‚", negative: "å†·æ·¡åœ°å›æ‡‰ã€‚" }, openness: { positive: "å¥½å¥‡åœ°çœ‹è‘—ä½ ï¼Œå•ä½ å¾å“ªä¾†ï¼Ÿ", negative: "è­¦æƒ•åœ°ä¿æŒè·é›¢ã€‚" } }, emotionImpact: { joy: .2 } },
      help: { baseResponse: "æˆ‘ä¾†å¹«ä½ ã€‚", personalityEffects: { agreeableness: { positive: "é¦¬ä¸Šæ”¾ä¸‹æ‰‹é‚Šçš„äº‹ä¾†å¹«ä½ ï¼", negative: "å˜–ï¼ŒçœŸéº»ç…©..." }, conscientiousness: { positive: "è©³ç´°è©¢å•ä½ éœ€è¦ä»€éº¼å…·é«”å¹«åŠ©ã€‚", negative: "éš¨ä¾¿å¹«äº†ä¸€ä¸‹ã€‚" }, extraversion: { positive: "å¤§è²æ‹›å‘¼å…¶ä»–äººä¸€èµ·ä¾†å¹«å¿™ã€‚", negative: "é»˜é»˜åœ°éä¸Šå·¥å…·ã€‚" } }, emotionImpact: { joy: .1 } },
      attack: { baseResponse: "æœ‰æ•µæ„ï¼", personalityEffects: { neuroticism: { positive: "å°–å«è‘—å¾Œé€€ï¼", negative: "å†·éœåœ°æ‹”å‡ºæ­¦å™¨ã€‚" }, agreeableness: { positive: "è©¦åœ–è®“ä½ å†·éœä¸‹ä¾†ï¼", negative: "æ—¢ç„¶ä½ æƒ³æ‰“ï¼Œé‚£å°±ä¾†å§ï¼" }, conscientiousness: { positive: "åˆ†æä½ çš„æˆ°é¬¥æ¶å‹¢ã€‚", negative: "æ…Œäº‚åœ°å››è™•é€ƒç«„ã€‚" } }, emotionImpact: { anger: .4, fear: .3 } },
      gift: { baseResponse: "è¬è¬ã€‚", personalityEffects: { agreeableness: { positive: "å¤ªæ„Ÿè¬äº†ï¼æˆ‘æœƒå¥½å¥½çæƒœçš„ã€‚", negative: "é€™æ±è¥¿æœ‰ä»€éº¼ä¼åœ–ï¼Ÿ" }, openness: { positive: "é€™æ˜¯ä»€éº¼æ–°å¥‡çš„æ±è¥¿ï¼ŸçœŸæœ‰è¶£ï¼", negative: "ä»”ç´°æª¢æŸ¥æœ‰æ²’æœ‰å±éšªã€‚" }, extraversion: { positive: "é–‹å¿ƒå¾—è·³äº†èµ·ä¾†ï¼", negative: "å®³ç¾åœ°æ”¶ä¸‹äº†ã€‚" } }, emotionImpact: { joy: .3 } },
      threaten: { baseResponse: "æ„Ÿåˆ°å¨è„…ã€‚", personalityEffects: { neuroticism: { positive: "åˆ¥æ®ºæˆ‘ï¼æˆ‘ä»€éº¼éƒ½è½ä½ çš„ï¼", negative: "æˆ‘ä¸å—ä½ çš„å¨è„…ã€‚" }, agreeableness: { positive: "æœ‰è©±å¥½èªªï¼Œæˆ‘å€‘å¯ä»¥è«‡è«‡ã€‚", negative: "ä½ æ‰¾éŒ¯äººäº†ã€‚" }, conscientiousness: { positive: "è©•ä¼°é›™æ–¹å¯¦åŠ›å·®è·ã€‚", negative: "åš‡å¾—èªç„¡å€«æ¬¡ã€‚" } }, emotionImpact: { fear: .5, anger: .2 } },
      explore: { baseResponse: "è€ƒæ…®æ¢ç´¢ã€‚", personalityEffects: { openness: { positive: "å¥½å•Šï¼æˆ‘ä¸€ç›´æƒ³å»é‚£é‚Šçœ‹çœ‹ï¼", negative: "å¤–é¢å¤ªå±éšªäº†å§ï¼Ÿ" }, conscientiousness: { positive: "ç­‰æˆ‘æº–å‚™å¥½åœ°åœ–å’Œç‰©è³‡ã€‚", negative: "èµ°å§èµ°å§ï¼ç›´æ¥å‡ºç™¼ï¼" }, extraversion: { positive: "æˆ‘ä¾†å¸¶è·¯ï¼", negative: "æˆ‘è·Ÿåœ¨ä½ å¾Œé¢å°±å¥½ã€‚" } }, emotionImpact: { joy: .2 } },
      trade: { baseResponse: "è€ƒæ…®äº¤æ˜“ã€‚", personalityEffects: { conscientiousness: { positive: "è®“æˆ‘ç®—ç®—é€™ç­†äº¤æ˜“åˆ’ä¸åˆ’ç®—...", negative: "å¥½å§ï¼Œéš¨ä¾¿è³£çµ¦ä½ ã€‚" }, agreeableness: { positive: "ç®—ä½ ä¾¿å®œä¸€é»å§æœ‹å‹ã€‚", negative: "é€™åƒ¹æ ¼å¤ªä½äº†ï¼Œå…è«‡ã€‚" }, openness: { positive: "é€™æ±è¥¿æˆ‘æ²’è¦‹éï¼Œæ›äº†ï¼", negative: "æˆ‘åªæ”¶é‡‘å¹£ã€‚" } }, emotionImpact: { joy: .1 } },
      joke: { baseResponse: "è½åˆ°ç¬‘è©±ã€‚", personalityEffects: { extraversion: { positive: "å“ˆå“ˆå“ˆå“ˆï¼å¤ªå¥½ç¬‘äº†ï¼", negative: "å¾®å¾®ä¸€ç¬‘ã€‚" }, openness: { positive: "é€™ç¬‘è©±æŒºæœ‰æ·±æ„çš„ã€‚", negative: "æˆ‘è½ä¸æ‡‚æ¢—åœ¨å“ªã€‚" }, agreeableness: { positive: "é›–ç„¶ä¸å¥½ç¬‘ï¼Œä½†é‚„æ˜¯ç¦®è²Œåœ°ç¬‘äº†ã€‚", negative: "ç„¡èŠã€‚" } }, emotionImpact: { joy: .3 } },
      sad_news: { baseResponse: "å¾—çŸ¥å£æ¶ˆæ¯ã€‚", personalityEffects: { neuroticism: { positive: "å¤©å•Šï¼æ€éº¼æœƒé€™æ¨£... (å´©æ½°)", negative: "é€™å°±æ˜¯äººç”Ÿ..." }, agreeableness: { positive: "æˆ‘å¾ˆéºæ†¾ï¼Œéœ€è¦æ“æŠ±å—ï¼Ÿ", negative: "å“¦ï¼ŒçŸ¥é“äº†ã€‚" }, extraversion: { positive: "æ‰¾äººå‚¾è¨´å¿ƒä¸­çš„æ‚²å‚·ã€‚", negative: "ç¨è‡ªèº²åœ¨è§’è½ã€‚" } }, emotionImpact: { sadness: .4, fear: .1 } }
    };

    /* ================== ä¸»è¦é‚è¼¯ ================== */

    function initializeSliders() {
      const traits = ['openness', 'conscientiousness', 'extraversion', 'agreeableness', 'neuroticism'];
      traits.forEach(trait => {
        const slider = document.getElementById(trait);
        const valueDisplay = document.getElementById(trait + '-value');
        const sync = (v) => { valueDisplay.textContent = Number(v).toFixed(1); npc.personality[trait] = v; };
        slider.addEventListener('input', function () {
          const v = parseFloat(this.value); sync(v);
          addLogEntry(`äººæ ¼èª¿æ•´: ${getTraitName(trait)} = ${v.toFixed(1)}`, 'decision');
        });
      });
      updateTrustBar();
    }

    // è¨˜æ†¶è™•ç†ç³»çµ± 
    function addMemory(type, desc, isNegative) {
      if (npc.memories.length >= 3) npc.memories.shift();
      npc.memories.push({ type, desc, isNegative, time: Date.now() });
      updateMemoryDisplay();
    }

    function hasMemory(type) {
      return npc.memories.some(m => m.type === type);
    }

    function updateMemoryDisplay() {
      const list = document.getElementById('memory-list');
      list.innerHTML = '';
      if (npc.memories.length === 0) {
        list.innerHTML = '<div style="font-style: italic; opacity: 0.6;">(å°šç„¡é—œéµè¨˜æ†¶)</div>';
        return;
      }
      npc.memories.forEach(m => {
        const div = document.createElement('div');
        div.className = `memory-item ${m.isNegative ? 'negative' : 'positive'}`;
        div.textContent = m.desc;
        list.appendChild(div);
      });
    }

    function executeCommand(command) {
      if (command === 'reset') { resetNPC(); return; }
      const behavior = behaviorDatabase[command];
      if (!behavior) return;

      // å¯«å…¥è¨˜æ†¶ï¼šé‡å°ç‰¹å®šäº‹ä»¶
      if (command === 'attack') addMemory('attack', 'æ›¾è¢«ç©å®¶æ”»æ“Š', true);
      if (command === 'gift' && npc.emotions.anger <= 0.5) addMemory('gift', 'æ”¶éç©å®¶ç¦®ç‰©', false);
      if (command === 'threaten') addMemory('threat', 'æ›¾è¢«ç©å®¶å¨è„…', true);
      // é‚è¼¯åˆ¤æ–·
      // æª¢æŸ¥æ˜¯å¦è¨˜ä»‡ï¼šæœ‰æ”»æ“Šè¨˜æ†¶ + ç¥ç¶“è³ªé«˜ (>0.6) = è¨˜ä»‡æ¨¡å¼
      const isGrudging = hasMemory('attack') && npc.personality.neuroticism > 0.6;
      // æª¢æŸ¥æ˜¯å¦æ‹’æ”¶ç¦®ç‰©
      const isRefusingGift = (command === 'gift' && npc.emotions.anger > 0.5);
      let response = "";
      if (isGrudging && command !== 'attack' && command !== 'threaten') {
        // ã€è¨˜ä»‡ã€‘é™¤äº†æˆ°é¬¥æŒ‡ä»¤å¤–ï¼Œå…¶ä»–äº’å‹•å…¨éƒ¨æ‹’çµ•
        updateEmotions({ anger: 0.05 });
        response = "(å†·æ¼ åœ°) æˆ‘é‚„è¨˜å¾—ä½ å°æˆ‘åšéä»€éº¼...èµ°é–‹ã€‚";
      }
      else if (isRefusingGift) {
        // ã€æ†¤æ€’æ‹’æ”¶ã€‘
        updateEmotions({ anger: 0.1 });
        response = "(æ†¤æ€’åœ°) æˆ‘ä¸éœ€è¦ä½ çš„åƒåœ¾ï¼æ‹¿èµ°ï¼";
      }
      else {
        // ã€æ­£å¸¸äº’å‹•ã€‘
        updateEmotions(behavior.emotionImpact);
        response = generatePersonalityResponse(behavior);
      }

      updateTrust(command);
      displayResponse(response);
      addLogEntry(`åŸ·è¡ŒæŒ‡ä»¤: ${getCommandName(command)}`, 'action');
      addLogEntry(`åæ‡‰: ${response}`, 'decision');

      lastTreeCmd = command;
      const tree = buildTreeFor(command);
      const traversal = [];
      const result = tree.tick({ npc, command }, traversal);
      drawBehaviorTree(tree, traversal);
    }

    function updateEmotions(impact) {
      const nScore = npc.personality.neuroticism;
      const sensitivity = 1 + (nScore * 0.5);

      for (const emo in impact) {
        let finalImpact = impact[emo] * sensitivity;
        npc.emotions[emo] = Math.min(1, npc.emotions[emo] + finalImpact);
      }

      if (impact.sadness || impact.anger || impact.fear) { npc.emotions.joy *= 0.5; }
      if (impact.joy) { npc.emotions.sadness *= 0.5; npc.emotions.anger *= 0.5; npc.emotions.fear *= 0.5; }

      for (const emo in npc.emotions) {
        if (!impact[emo]) npc.emotions[emo] = Math.max(0, npc.emotions[emo] * 0.9);
      }
      updatePrimaryEmotion();
    }

    function updateTrust(command) {
      const trustChanges = { greet: .05, help: -.1, attack: -.3, gift: .2, threaten: -.4, explore: .1, trade: .05, joke: .1, sad_news: -.05 };
      if (Object.prototype.hasOwnProperty.call(trustChanges, command)) {
        let rawChange = trustChanges[command];
        const p = npc.personality;
        if (hasMemory('attack') || hasMemory('threat')) {
          if (rawChange > 0) rawChange *= 0.5;
          else rawChange *= 1.5;
        }

        if (rawChange > 0) rawChange *= (0.5 + p.agreeableness);
        if (rawChange < 0) rawChange *= (1 + p.neuroticism * 0.5);
        if (command === 'explore' && p.openness > 0.7) rawChange *= 1.5;

        npc.trust = Math.max(0, Math.min(1, npc.trust + rawChange));
        updateTrustBar();
      }
    }

    /* è‡ªç„¶è¡°é€€ (å«æƒ…ç·’èˆ‡è¨˜æ†¶) */
    let decayTimer = null;

    function startEmotionDecay() {
      if (decayTimer) clearInterval(decayTimer);

      decayTimer = setInterval(() => {
        const nScore = npc.personality.neuroticism;

        // æƒ…ç·’è¡°é€€
        const decayRate = 0.01; 
        let emoChanged = false;
        for (const emo in npc.emotions) {
          const before = npc.emotions[emo];
          npc.emotions[emo] = Math.max(0, npc.emotions[emo] - decayRate);
          if (Math.abs(npc.emotions[emo] - before) > 0.001) emoChanged = true;
        }
        if (emoChanged) updatePrimaryEmotion();

        // 2. è¨˜æ†¶éºå¿˜é‚è¼¯
        // è¨˜æ†¶å£½å‘½ = åŸºç¤ 10ç§’ + (ç¥ç¶“è³ª * 20ç§’)
        // ç¥ç¶“è³ª 0.0 -> 10ç§’å¿˜è¨˜
        // ç¥ç¶“è³ª 1.0 -> 30ç§’å¿˜è¨˜
        const memoryLifeSpan = 10000 + (nScore * 20000);
        const now = Date.now();

        const originalCount = npc.memories.length;
        npc.memories = npc.memories.filter(m => (now - m.time) < memoryLifeSpan);

        if (npc.memories.length !== originalCount) {
          updateMemoryDisplay();
          addLogEntry("æ™‚é–“æµé€ï¼ŒNPC å¿˜è¨˜äº†ä¸€äº›äº‹...", "decision");

          // å¦‚æœå› ç‚ºå¿˜è¨˜ä»‡æ¨è€Œè§£é–äº’å‹•ï¼Œé‡æ–°ç¹ªè£½è¡Œç‚ºæ¨¹
          if (lastTreeCmd) {
            const tree = buildTreeFor(lastTreeCmd);
            const traversal = [];
            tree.tick({ npc, command: lastTreeCmd }, traversal);
            drawBehaviorTree(tree, traversal);
          }
        }

      }, 1000); // æ”¹ç‚ºæ¯ 1000ms (1ç§’) åŸ·è¡Œä¸€æ¬¡
    }

    function getTraitName(trait) { return ({ openness: 'é–‹æ”¾æ€§', conscientiousness: 'ç›¡è²¬æ€§', extraversion: 'å¤–å‘æ€§', agreeableness: 'å®œäººæ€§', neuroticism: 'ç¥ç¶“è³ª' })[trait] || trait; }
    function getEmotionName(key) { return ({ neutral: 'å¹³éœ', joy: 'æ„‰æ‚…', anger: 'æ†¤æ€’', fear: 'ææ‡¼', sadness: 'æ‚²å‚·' })[key] || key; }
    function getCommandName(cmd) { return ({ greet: 'æ‰“æ‹›å‘¼', help: 'è«‹æ±‚å¹«åŠ©', attack: 'ç™¼èµ·æ”»æ“Š', gift: 'è´ˆé€ç¦®ç‰©', threaten: 'å¨è„…æåš‡', explore: 'é‚€è«‹æ¢ç´¢', trade: 'å•†æ¥­äº¤æ˜“', joke: 'èªªç¬‘è©±', sad_news: 'å‘ŠçŸ¥å£æ¶ˆæ¯' })[cmd] || cmd; }

    function generatePersonalityResponse(behavior) {
      const parts = [];
      for (const trait in behavior.personalityEffects) {
        const v = npc.personality[trait];
        const eff = behavior.personalityEffects[trait];
        if (v > 0.6 && eff.positive) parts.push(eff.positive);
        else if (v < 0.4 && eff.negative) parts.push(eff.negative);
      }
      let base = behavior.baseResponse;
      if (parts.length > 0) base = parts.join(" ä¸” ");
      const strength = getCurrentEmotionStrength();
      if (strength > 0.3) base = applyEmotionalModifier(base);
      return base;
    }

    function updatePrimaryEmotion() {
      let maxKey = 'neutral', maxVal = 0;
      for (const emo in npc.emotions) { if (npc.emotions[emo] > maxVal) { maxVal = npc.emotions[emo]; maxKey = emo; } }
      if (maxVal < 0.2) maxKey = 'neutral';
      npc.currentEmotion = maxKey; updateCharacterDisplay();
      addLogEntry(`æƒ…ç·’è®Šæ›´: ${getEmotionName(maxKey)} (${maxVal.toFixed(2)})`, 'emotion');
    }

    function updateCharacterDisplay() {
      const character = document.getElementById('character');
      const emotionDisplay = document.getElementById('current-emotion');
      const statusDisplay = document.getElementById('character-status');
      character.className = 'character';
      switch (npc.currentEmotion) {
        case 'joy': character.classList.add('happy'); character.textContent = 'ğŸ˜Š'; break;
        case 'anger': character.classList.add('angry'); character.textContent = 'ğŸ˜ '; break;
        case 'sadness': character.classList.add('sad'); character.textContent = 'ğŸ˜¢'; break;
        case 'fear': character.classList.add('fearful'); character.textContent = 'ğŸ˜¨'; break;
        default: character.textContent = 'ğŸ¤–';
      }
      emotionDisplay.textContent = `æƒ…ç·’: ${getEmotionName(npc.currentEmotion)}`;
    }

    function updateTrustBar() {
      document.getElementById('trust-bar').style.width = (npc.trust * 100) + '%';
      document.getElementById('trust-value').textContent = npc.trust.toFixed(2);
    }

    function displayResponse(text) {
      const status = document.getElementById('character-status');
      status.textContent = text;
      status.style.animation = 'none';
      status.offsetHeight;
      status.style.animation = 'slideIn 0.3s ease';
    }

    function addLogEntry(msg, type = 'action') {
      const log = document.getElementById('log-area');
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      const ts = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
      entry.textContent = `[${ts}] ${msg}`;
      log.appendChild(entry);
      log.scrollTop = log.scrollHeight;
    }

    function resetNPC() {
      npc.emotions = { joy: 0, anger: 0, fear: 0, sadness: 0 };
      npc.memories = []; // æ¸…ç©ºè¨˜æ†¶
      npc.currentEmotion = 'neutral';
      npc.trust = .5;
      updateMemoryDisplay();
      updateTrustBar(); updateCharacterDisplay();
      addLogEntry('NPCç‹€æ…‹å·²é‡ç½® (å«è¨˜æ†¶)', 'action');
      document.getElementById('character-status').textContent = 'å·²é‡ç½®ï¼Œç­‰å¾…æ–°æŒ‡ä»¤...';
      const initTree = new Selector('Root');
      drawBehaviorTree(initTree, []);
    }

    function getCurrentEmotionStrength() { return npc.emotions[npc.currentEmotion] || 0; }

    function applyEmotionalModifier(text) {
      const map = { joy: "(é–‹å¿ƒåœ°) ", anger: "(æ†¤æ€’åœ°) ", sadness: "(æ‚²å‚·åœ°) ", fear: "(é¡«æŠ–åœ°) " };
      const p = map[npc.currentEmotion];
      return p ? (p + text) : text;
    }

    /* ================== è¡Œç‚ºæ¨¹æ ¸å¿ƒ ================== */
    const BTStatus = { SUCCESS: 'SUCCESS', FAILURE: 'FAILURE', RUNNING: 'RUNNING' };

    class BTNode {
      constructor(type, label = '') { this.type = type; this.label = label; this.children = []; this.parent = null; this.x = 0; this.y = 0; this.id = Math.random().toString(36).slice(2, 9); }
      add(child) { child.parent = this; this.children.push(child); return this; }
      tick(ctx, trace) { trace.push({ id: this.id, type: this.type }); return BTStatus.SUCCESS; }
    }
    class Selector extends BTNode {
      constructor(label = 'Selector') { super('selector', label); }
      tick(ctx, trace) {
        trace.push({ id: this.id, type: this.type });
        for (const c of this.children) {
          const r = c.tick(ctx, trace);
          if (r === BTStatus.SUCCESS || r === BTStatus.RUNNING) return r;
        }
        return BTStatus.FAILURE;
      }
    }
    class Sequence extends BTNode {
      constructor(label = 'Sequence') { super('sequence', label); }
      tick(ctx, trace) {
        trace.push({ id: this.id, type: this.type });
        for (const c of this.children) {
          const r = c.tick(ctx, trace);
          if (r === BTStatus.FAILURE || r === BTStatus.RUNNING) return r;
        }
        return BTStatus.SUCCESS;
      }
    }
    class Condition extends BTNode {
      constructor(label, fn) { super('condition', label); this.fn = fn; }
      tick(ctx, trace) {
        trace.push({ id: this.id, type: this.type });
        return this.fn(ctx) ? BTStatus.SUCCESS : BTStatus.FAILURE;
      }
    }
    class Action extends BTNode {
      constructor(label, fn) { super('action', label); this.fn = fn; }
      tick(ctx, trace) {
        trace.push({ id: this.id, type: this.type });
        return this.fn ? (this.fn(ctx) || BTStatus.SUCCESS) : BTStatus.SUCCESS;
      }
    }

    function buildTreeFor(command) {
      const { personality: p, emotions: e, trust } = npc;
      const root = new Selector('Root');

      // 0) è¨˜æ†¶èˆ‡è¨˜ä»‡ç³»çµ± (æ–°å¢çš„æœ€é«˜å„ªå…ˆç´š)
      // å¦‚æœæœ‰æ”»æ“Šè¨˜æ†¶ ä¸” ç¥ç¶“è³ªé«˜ -> æ‹’çµ•äº’å‹•
      const branchGrudge = new Sequence('è¨˜ä»‡ç³»çµ±')
        .add(new Condition('æ˜¯å¦æœ‰ä»‡?', () => hasMemory('attack')))
        .add(new Condition('ç¥ç¶“è³ªé«˜(è¨˜ä»‡)?', () => p.neuroticism > 0.6))
        .add(new Condition('éæˆ°é¬¥æŒ‡ä»¤?', ({ command }) => command !== 'attack' && command !== 'threaten'))
        .add(new Action('å†·æ¼ æ‹’çµ•äº’å‹•'));

      // 1) ç”Ÿå­˜èˆ‡å®‰å…¨
      const branchSafety = new Sequence('ç”Ÿå­˜å¨è„…æª¢æ¸¬')
        .add(new Condition('æ˜¯å¦å—å¨è„…?', ({ command }) => command === 'attack' || command === 'threaten' || e.fear > 0.45))
        .add(new Selector('é˜²ç¦¦ç­–ç•¥')
          .add(new Sequence('å’Œå¹³è«‡åˆ¤')
            .add(new Condition('é«˜å®œäºº/ç›¡è²¬?', () => p.agreeableness > 0.6 || p.conscientiousness > 0.6))
            .add(new Action('å®‰æ’«èˆ‡è«‡åˆ¤')))
          .add(new Sequence('é€ƒè·‘/æ±‚æ´')
            .add(new Condition('é«˜ç¥ç¶“è³ªæˆ–ä¸ä¿¡ä»»?', () => p.neuroticism > 0.6 || trust < 0.3))
            .add(new Action('æ’¤é€€èˆ‡æ±‚æ•‘')))
          .add(new Action('æº–å‚™åæ“Š')));

      // 2) ç¤¾äº¤äº’å‹•
      const branchSocial = new Selector('ç¤¾äº¤äº’å‹•ç³»çµ±')
        .add(new Sequence('æ¥å—ç¦®ç‰©è™•ç†')
          .add(new Condition('æ”¶åˆ°ç¦®ç‰©?', ({ command }) => command === 'gift'))
          .add(new Selector('ç¦®ç‰©åæ‡‰æ±ºç­–')
            .add(new Sequence('æ†¤æ€’æ‹’æ”¶')
              .add(new Condition('æ¥µåº¦æ†¤æ€’?', () => e.anger > 0.5))
              .add(new Action('æŠŠç¦®ç‰©æ‰”å›å»')))
            .add(new Sequence('æ‡·ç–‘å‹•æ©Ÿ')
              .add(new Condition('ç¥ç¶“è³ªé«˜?', () => p.neuroticism > 0.7))
              .add(new Action('æª¢æŸ¥ç¦®ç‰©')))
            .add(new Action('é–‹å¿ƒæ¥å—'))))
        .add(new Sequence('ä¸€èˆ¬å¯’æš„')
          .add(new Condition('æ‰“æ‹›å‘¼/ç©ç¬‘?', ({ command }) => command === 'greet' || command === 'joke'))
          .add(new Action('å›æ‡‰å°è©±')))
        .add(new Sequence('å•†æ¥­äº¤æ˜“')
          .add(new Condition('äº¤æ˜“è«‹æ±‚?', ({ command }) => command === 'trade'))
          .add(new Condition('ç›¡è²¬æ€§åˆæ ¼?', () => p.conscientiousness > 0.3))
          .add(new Action('è©•ä¼°åƒ¹å€¼')))
        .add(new Sequence('æ¢ç´¢é‚€è«‹')
          .add(new Condition('æ¢ç´¢è«‹æ±‚?', ({ command }) => command === 'explore'))
          .add(new Condition('é–‹æ”¾æ€§é«˜?', () => p.openness > 0.4 || e.joy > 0.3))
          .add(new Action('åŒæ„å‡ºç™¼')));

      // 3) æƒ…æ„Ÿæ”¯æ´
      const branchEmpathy = new Selector('æƒ…æ„ŸéŸ¿æ‡‰')
        .add(new Sequence('å›æ‡‰æ±‚åŠ©')
          .add(new Condition('æœ‰äººæ±‚åŠ©?', ({ command }) => command === 'help'))
          .add(new Condition('éå†·æ¼ ?', () => p.agreeableness > 0.3))
          .add(new Action('æä¾›å”åŠ©')))
        .add(new Sequence('è™•ç†å£æ¶ˆæ¯')
          .add(new Condition('æ”¶åˆ°å£æ¶ˆæ¯?', ({ command }) => command === 'sad_news'))
          .add(new Action('è¡¨é”åŒæƒ…')));

      const fallback = new Action('é–’ç½®/è§€å¯Ÿ');

      // å°‡è¨˜ä»‡åˆ†æ”¯åŠ å…¥æ ¹ç¯€é»çš„æœ€å‰é¢
      root.add(branchGrudge).add(branchSafety).add(branchSocial).add(branchEmpathy).add(fallback);
      return root;
    }

    /* ================== ç¹ªè£½èˆ‡ä½ˆå±€ (ç¶­æŒåŸæ¨£) ================== */
    const svg = document.getElementById('bt-svg');
    let SHOW_EN = false;
    let lastTreeCmd = null;

    function drawBehaviorTree(root, traversal) {
      const defs = svg.querySelector('defs');
      svg.innerHTML = ''; if (defs) svg.appendChild(defs);

      const levels = {}; const nodes = [];
      (function dfs(node, depth = 0) {
        if (!levels[depth]) levels[depth] = [];
        node.depth = depth; levels[depth].push(node); nodes.push(node);
        node.children.forEach(c => dfs(c, depth + 1));
      })(root);

      const levelCount = Object.keys(levels).length;
      let maxNodesInLevel = 0;
      for (let l in levels) maxNodesInLevel = Math.max(maxNodesInLevel, levels[l].length);

      const nodeWidth = 120, nodeHeight = 40, xGap = 180, yGap = 80;
      const requiredWidth = Math.max(800, 100 + levelCount * xGap);
      const requiredHeight = Math.max(500, 100 + maxNodesInLevel * yGap);

      svg.setAttribute('width', requiredWidth);
      svg.setAttribute('height', requiredHeight);

      Object.keys(levels).forEach(d => {
        const nodesAtLevel = levels[d];
        const totalH = nodesAtLevel.length * yGap;
        const startY = (requiredHeight - totalH) / 2;
        nodesAtLevel.forEach((n, i) => {
          if (!n._fixed) { n.x = 50 + d * xGap; n.y = startY + i * yGap; }
        });
      });

      nodes.forEach(n => {
        n.children.forEach(c => {
          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('class', 'link');
          path.setAttribute('d', makeLinkPath(n.x + nodeWidth, n.y + nodeHeight / 2, c.x, c.y + nodeHeight / 2));
          svg.appendChild(path);
          if (!n._links) n._links = [];
          n._links.push({ to: c, el: path });
        });
      });

      const visited = new Set(traversal.map(t => t.id));
      nodes.forEach(n => {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('class', `node ${n.type}`);
        g.setAttribute('transform', `translate(${n.x},${n.y})`);

        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('width', nodeWidth); rect.setAttribute('height', nodeHeight);
        g.appendChild(rect);

        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', nodeWidth / 2); text.setAttribute('y', nodeHeight / 2 + 4); text.setAttribute('text-anchor', 'middle');

        const typeLabelMap = { selector: 'Selector', sequence: 'Sequence', condition: 'Condition', action: 'Action' };
        const cnLabelMap = { selector: 'é¸æ“‡å™¨ (?)', sequence: 'åºåˆ— (â†’)', condition: 'æ¢ä»¶', action: 'è¡Œå‹•' };
        let labelText = SHOW_EN ? typeLabelMap[n.type] : (n.label || cnLabelMap[n.type]);
        if (labelText.length > 8 && !n.label) labelText = labelText.substring(0, 8) + '..';
        text.textContent = labelText;
        g.appendChild(text);

        if (visited.has(n.id)) {
          g.classList.add('success');
          if (n.parent && visited.has(n.parent.id)) {
            const linkObj = n.parent._links.find(l => l.to === n);
            if (linkObj) { linkObj.el.classList.add('active'); linkObj.el.setAttribute('marker-end', 'url(#arrow-active)'); }
          }
        }
        enableDrag(g, n, nodeWidth, nodeHeight);
        svg.appendChild(g);
      });
    }

    function makeLinkPath(x1, y1, x2, y2) { const mx = (x1 + x2) / 2; return `M ${x1} ${y1} C ${mx} ${y1}, ${mx} ${y2}, ${x2} ${y2}`; }

    function enableDrag(g, node, w, h) {
      let start = null;
      const onDown = (e) => {
        e.preventDefault();
        const pt = svg.createSVGPoint(); pt.x = e.clientX; pt.y = e.clientY;
        const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
        start = { x: svgP.x, y: svgP.y, nx: node.x, ny: node.y };
        node._fixed = true;
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp, { once: true });
        g.style.cursor = 'grabbing';
      };
      const onMove = (e) => {
        if (!start) return;
        const pt = svg.createSVGPoint(); pt.x = e.clientX; pt.y = e.clientY;
        const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
        node.x = start.nx + (svgP.x - start.x); node.y = start.ny + (svgP.y - start.y);
        g.setAttribute('transform', `translate(${node.x},${node.y})`);
        if (node.parent && node.parent._links) {
          const link = node.parent._links.find(l => l.to === node);
          if (link) link.el.setAttribute('d', makeLinkPath(node.parent.x + w, node.parent.y + h / 2, node.x, node.y + h / 2));
        }
        if (node._links) {
          node._links.forEach(({ to, el }) => { el.setAttribute('d', makeLinkPath(node.x + w, node.y + h / 2, to.x, to.y + h / 2)); });
        }
      };
      const onUp = () => { start = null; window.removeEventListener('mousemove', onMove); g.style.cursor = 'grab'; };
      g.addEventListener('mousedown', onDown); g.style.cursor = 'grab';
    }

    document.getElementById('btn-relayout').addEventListener('click', () => {
      if (lastTreeCmd) {
        const tree = buildTreeFor(lastTreeCmd);
        const traversal = []; tree.tick({ npc, command: lastTreeCmd }, traversal);
        drawBehaviorTree(tree, traversal);
      }
    });

    document.getElementById('btn-toggle-label').addEventListener('click', function () {
      SHOW_EN = !SHOW_EN;
      this.textContent = SHOW_EN ? "é¡¯ç¤ºï¼šè‹±æ–‡å‹åˆ¥" : "é¡¯ç¤ºï¼šä¸­æ–‡æè¿°";
      if (lastTreeCmd) {
        const tree = buildTreeFor(lastTreeCmd);
        const traversal = []; tree.tick({ npc, command: lastTreeCmd }, traversal);
        drawBehaviorTree(tree, traversal);
      }
    });

    document.addEventListener('DOMContentLoaded', () => {
      initializeSliders();
      updateCharacterDisplay();
      startEmotionDecay();
      const initTree = new Selector('Root');
      drawBehaviorTree(initTree, []);
    });
  </script>
</body>

</html>